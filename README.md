# JSMA - Java Server Management Automation
Python-сервис для запуска Spring Boot java-серверов


# Задачи
- упростить запуск и остановку скомпилированных JAVA приложений-серверов
- простейший мониторинг за работоспособностью приложения (проверка, работает приложение или нет)


# Идея
Это Python-приложение предоставляет набор команд для запуска, остановки, проверки жизнеспособности java-приложений.
Чтобы не приходилось явно прописывать

    nohup java -Dspring.profiles.active=[spring-profile] -jar application-0.1.0.jar >> system.out 2>&1 &


# Для работы потребуется
- Python 2.7
- virtualenv
- python-dev (опционально - зависит от используемых дополнительных Python модулей)


# Установка
1. Убедиться, что на целевой машние установлен Python 2.7 или выше, но обязательно 2-ой версии
2. `sudo apt-get python-virtualenv`
3. `sudo apt-get install python-dev`
4. Положить файлы данного проекта на целевую машину, например, склонировать Git-репозиторий.
5. Объявить функцию, например, прописав её файле ~/.bashsrc.

        function server () {
            source PATH_TO_JSMA/bin/jsma.sh "$@"
        }


# Использование
Все команды нужно выполнять из папки с файлами java-приложения сервера.

## Запуск приложения
`server start --%[spring_profile] [jvm_args]`

Алгоритм:

- ищется единственный jar-файл, он понимается как приложение, которое надо будет запустить (например, app.jar)
- его stdout перенаправляется в файл ./system.out
- запускается процесс в фоне. выполняется команда: `java -Dspring.profiles.active=[spring_profile] [jvm_args] -jar
 app.jar`
- pid запущенного процесса пишется в файл server.pid
- spring-профиль пишется в файл spring.profile

Пример указания профиля `--%development`. Профиль может быть передан любым по счету параметром, даже между `[jvm-args]`.

### Взаимодействие с запускаемым приложением
Вводиться соглашение по информированию. Чтобы JSMA понимало, что запускаемое приложение удачно запустилось или наоборот
запуск не удался, целевое приложение обязано писать в поток вывода строки оговоренного формата.

<table>
    <thead>
        <tr>
            <td>статус</td>
            <td>строка</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>приложение удачно запустилось</td>
            <td>APP_START_RESULT: STARTED</td>
        </tr>
        <tr>
            <td>приложение не запустилось</td>
            <td>APP_START_RESULT: NOT STARTED</td>
        </tr>
    </tbody>
</table>

JSMA ждет появление этих строк в течении таймаута на запуск, если такие строки не появились, то считается, что запуск
сорвался, приложению шлется сигнал `-TERM (15)` на закрытие (unix-команда `kill 15`).

## Остановка приложения
`server stop`

Алгоритм:
   
- ищется файл server.pid, из него читатся pid запущенного процесса
- убивается процесс по его pid. unix-команда kill.

## Проверка статуса
`server status`

Алгоритм:

- ищется файл server.pid, из него читатся pid запущенного процесса
- смотрим, функционирует ли сейчас процесс с таким pid

## Дополнительные парамеры
- Таймаут на запуск.
  
        --start-timeout=NUMBER
    где `NUMBER` - целое число. Количество секунд, сколько ждем от приложения сигнализации об успешном старте.
    Анализируется при выполнении команды `start`.

- Таймаут на остановку 
   
        --stop-timeout=NUMBER
    где `NUMBER` - целое число. Количество секунд, сколько ждем от приложения остановки. Анализируется при выполнении
    команд `start` и `stop`.

- Расширение запускаемого файла

        --executable-extension=STRING
    где `STRING` - строка. Раширение файла, который нужно запускать. Например: `jar`, `war`. Значение по умолчанию: `jar`. 

# Настройка IntelliJ IDEA
- устанавливаем все необходимое (Python, virtualenv, python-dev и т.д.)
- открываем терминал
- `virtualenv .venv`
- `source .venv/bin/activate`
- `pip install -r requirements/requirements.txt`
- убеждаемся, что в IDEA установлен плагин для Python
- заходим в "Project Structure" 
- вкладка "Project", раздел "Project SDK" - жмем "New..."
- выбираем "Python SDK", "Add local", указываем PATH_TO_PROJECT/.venv/bin/python2.7

# Известные проблемы

Бывает, что требуется дополнительная конфигурация локалей. Если этого не сделано, но не устанавливается virtualenv.

Для решения проблемы можно попробовать что-то из предложенного здесь: https://github.com/certbot/certbot/issues/2883
